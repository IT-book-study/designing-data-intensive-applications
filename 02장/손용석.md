## 관계형 모델과 문서 모델
오늘날 가장 잘 알려진 데이터 모델
- 1970년 에드가 코드가 제안한 관계형 모델을 기반으로 한 SQL이다.

데이터는 (SQL에서는 테이블이라 불리는) 관계로 구성되고 각 관계는 순서 없는 튜플(SQL에서 로우) 모음이다.
-> 관계형 데이터베이스 관리시스템(RDBMS)과 SQL은 정규화된 구조로 데이터를 저장하고 질의할 필요가 없는 사람들 대부분이 선택하는 도구가 됐다.

비즈니스 데이터 처리
- 트랜잭션 처리
- 일괄 처리

### NoSQL의 탄생
- 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요
- 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
- 관계형 모델에서 지원하지 않는 특수 질의 동작
- 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람

**다중 저장소 지속성**

### 객체 관계형 불일치
임피던스 불일치
데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체(테이블, 로우, 컬럼) 사이에 거추장스러운 전환 계층이 필요

액티브레코드, 하이버네이트와 같은 객체 관계형 매핑 프레임워크는 전환 계층에 필요한 상용구 코드의 양을 줄이지만 두 모델 간의 차이를 완벽하게 숨길 수 없다.

JSON 표현은 다중 테이블 스키마보다 더 나은 지역성을 갖는다.
모든 관련 정보가 한 곳에 있어 질의 하나로 충분하다
1:N 관계는 의미상 데이터 트리 구조와 같으며 JSON표현에서 명시적으로 드러난다

![[Pasted image 20240122232156.png]]![[Pasted image 20240122232220.png]]

### 다대일과 다대다 관계
region_id / industry_id가 평문이 아닌 id값으로 주어진 이유
- 프로필 간 일관된 스타일과 철자
- 모호함 회피(예를 들어 이름이 같은 여러 도시가 있는 경우)
- 갱신의 편의성. 이름이 한 곳에만 저장되므로 이름을 변경해야 하는 경우 전반적으로 갱신하기 쉽다 (예를 들어 저치적 사건으로 도시 이름이 변경되는 경우)
- 현재화 지원, 사이트를 다른 언어로 번역할 때 표준 목록을 현지화해 지역과 업계를 사이트를 보는 사람의 언어로 표시할 수 있다.
- 더 나은 검색. 예를 들어 워싱턴 주에 있는 자선가를 검색하려 할 때 지역 목록에 시애틀이 워싱턴에 있다는 사실을 부호화("그레이터 시애틀 구역" 문자열로는 "워싱턴"을 식별하지 못함) 할 수 있기 때문에 원하는 프로필을 찾을 수 있다.

중복된 데이터를 정규화하려면 "다대일" 관계가 필요하다.
- 문서 모델에 적합하지 않다.  일대다 트리 구조를 위해 조인이 필요하지 않지만 조인에 대한 지원이 보통 약하다.
- 관계형 데이터베이스에서는 조인이 쉽기 때문에 ID로 다른 테이블의 로우를 참조하는 방식은 일반적이다.

## 문서 데이터베이스는 역사를 반복하고 있나?
### 네트워크 모델
**코다실 모델**이라고도 부른다.
- 계층 모델을 일반화한다.
- 다중 부모가 있을 수 있다.
    - N:1 혹은 N:N 관계를 모델링 할 수 있다.
        - "서울대학교"의 부모로 "서울대학교 재학생들"이 올 수 있다.

레코드 간 연결은 프로그래밍 언어의 포인터와 비슷하다. (여전히 디스크에 저장되긴 한다.)
레코드에 접근하는 유일한 방법은 최상위 레코드에서부터 연속된 연결 경로를 따르는 방법이다.
이를 **접근경로** 라 한다.

다중 부모를 가진다면 애플리켕션 코드는 다양한 관계를 모두 추적해야 한다.

### 관계형 모델
알려진 모든 데이터를 배치하는 것.
관계(테이블)는 단순히 튜플(로우)의 컬렉션이 전부.

질의 최적화기 (query optimizer)는 질의의 어느 ㅜ분을 어떤 순서로 실행할지를 결정하고 사용할 색인을 자동으로 결정한다.
**접근경로** 이다.
네트워크모델과 다르게, 애플리케이션 개발자가 아닌 질의 최적화기가 자동으로 만든다.

새로운 방식으로 데이터에 질의를 하고 싶다면, 새로운 색인을 선언하기만 하면 자동으로 가장 적합한 색인을 사용한다.

### 문서 데이터베이스와의 비교
N:1 혹은 N:N 관계를 표현할 때 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 동일하다.
관련 항목은 고유한 식별자로 참조한다.
관계형 모델에서는 **외래키** , 문서 모델에서는 **문서 참조** 라 부른다.


문서 데이터모델 : 스키마 유연성, 지역성에 기인한 더 나은 성능, 애플리케이션에서 사용하는 데이터 구조와 더 가깝기 때문
관계형모델 : 조인, 다대일, 다대다 관계를 더 잘 지원하기 때문

#### 문서 모델의 제한
- 문서 내 중첩 항목을 바로 참조할 수 없다.
    - position의 두번째 항목을 바로 찾아갈 수 없다.
      "사용자 251"의 position의 두번째 항목 과 같은 방법으로 표기해야한다.
```JSON
 {
	 user_id: 251,
	position: [
		{
			name: '학생',
		},
		{
			name: '회사원'
		}
	]
 }
```

문서의 Depth가 너무 깊지 않다면 문제가 되지는 않는다.
애플리케이션에서 다대다 관계를 사용한다면 문서 모델은 매력이 떨어진다.

### 문서 모델에서의 스키마 유연성
대부분의 문서 데이터베이스와 관계형 데이터베이스에서 지원하는 JSON은 문서의 데이터에 어떤 스키마를 강요하지 않는다.

관계형 데이터베이스에서 제공하는 XML은 선태적으로 스키마 유효성 검사를 포함할 수 있다.
스키마가 없다 -> 임의의 키와 값을 문서에 추가할 수 있고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는다는 의미.

문서데이터베이스
스키마리스라 불리지만 이는 오해.
데이터를 읽는 코드는 보통 구조의 유형을 어느정도 가정한다.

#### 쓰기 스키마
관계형 데이터베이스의 전통적인 접근 방식으로 스키마는 명시적이고 데이터 베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장한다.
정적(컴파일 타임) 타입 확인과 비슷
**마이그레이션**을 통해, 모든 스키마에 값을 채워넣어줘야한다.
- 스키마 변경은 느리고 중단시간을 요구하기 때문에 평판이 좋지 않다.
- ALTER 수행 시 대부분은 빨리 끝난다.
    - MySQL은 ALTER Table 수행 시 전체 테이블을 복사한다. -> MySQL이 유독 느린 것.
#### 읽기 스키마
데이터 구조는 암묵적이고 데이터를 읽을 때만 해석된다.
동적(런타임) 타입 확인과 유사
구조가 변경이 되었을 때는 애플리케이션에서는 예전 문서를 읽은 경우를 처리하는 코드만 있으면 됨.
컬렉션 안의 항목이 어떤 이유로 모두 동일한 구조가 아닐 때 유리함.
- 다른 여러 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체 테이블에 넣는 방법은 실용적이지 않다.
- 사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정된다.

### 질의를 위한 데이터 지역성
애플리케이션이 자주 전체 문서에 접근해야할 때 **저장소 지역성**을 활용하면 성능 이점이 있다.
- 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용

문서를 아주 작게 유지하면서 문서의 크기가 증가하는 쓰기를 피하라 권장
- 문서의 작은 부분을 접근해도 전체 문서를 적재해야 하기에 큰 문서는 낭비
- 문서를 갱신할 때도 보통 전체 문서를 재작성해야한다.
- 부호화된 문서의 크기를 바꾸지 않는 수정은 쉽게 수행이 가능.

#### 지역성을 위해 관련 데이터를 함께 그룹화하는 개념
구글 : 스패너 데이터베이스 (부모 테이블 내에 (중첩되게) 테이블의 로우를 교차 배치되게끔 선언하는 스키마를 허용해 관계형 데이터 모델에서 지역성 특성을 동일하게 제공)
오라클 - 다중 테이블 색인 클러스트 테이블
카산드라, HBase - 빅테이블 데이터 모델의 **칼럼 패밀리** 개념


### 데이터를 위한 질의 언어
SQL은 **선언형** 질의 언어.

SQL이나 관계 대수 같은 선언형 질의 언어에서는 목표를 달성하기 위한 방법이 아니라 알고자 하는 데이터의 패턴, 즉 결과가 충족해야 하는 조건과 데이터를 어떻게 변환 (예를 들어 정렬, 그룹화, 집계) 할지를 지정하기만 하면 된다.
- 방법에 관해서는 데이터베이스 시스템의 질의 최적화기가 할 일이다.

병렬 실행에 적합하다.
결과를 결정하기 위한 알고리즘을 지정하는게 아니라 결과의 패턴만 지정하기 때문에 병렬 실행으로 더 빨라질 가능성이 크다.
가능한 경우 데이터베이스는 질의 언어의 병렬 구현을 마음껏 사용할 수 있다.

### 웹에서의 선언형 질의
CSS, XSL을 이용할 수 있다.
마찬가지로 데이터베이스에서는 SQL 같은 선언형 질의 언어가 명령형 질의 API보다 훨씬 좋다고 나타났다.
- 명령형 API에 대한 이슈들에 대한 예제 정도....

### 맵듀리스 질의
많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델
- 몽고DB, 카우치DB를 포함한 일부 NoSQL 데이터 저장소는 제한된 형태의 맵듀리스를 지원한다.
- **읽기 전용 질의**를 수행할 때 사용한다.

선언형 질의 언어도 완전한 명령형 질의 API도 아닌 그 중간 정도에 존재.
- 질의 로직은 처리 프레임워크가 반복적으로 호출하는 조각 코드로 표현한다.
- map(collect)와 recude(fold나 inject) 함수를 기반으로 한다.

몽고 DB의 map과 reduce함수는 수행할 때 약간 제약사항이 존재.
두 함수는 순수(pure) 함수여야한다.
- 입력으로 전달된 데이터만 사용하고 추가적인 데이터베이스 질의를 수행할 수 없어야하며 부수 효과가 없어야한다.

맵듀리스는, 상당히 저수준 프로그래밍 모델이다.
- SQL 같은 고수준 질의 언어도 맵듀리스 연산의 파이프라인으로 구현할 수 있지만 사용하지 않는 분산 SQL 구현도 많다.
- 일부 SQL 데이터베이스도 자바스크립트 함수로 확장될 수 있다.

사용성 문제
- 연계된 자바스크립트 함수 두 개를 신중하게 작성해야한다는 점인데, 이는 종종 하나의 질의를 작성하는 것보다 어렵다.
- 선언형 질의 언어는 질의 최적화기가 질의 성능을 높일 수 있는 기회를 제공
    - 몽고DB 2.2는 집게 파이프라인이라 부르는 선언형 질의 언어 지원을 추가하였다.

집계파이프라인
- 표현적인 측면에서 SQL의 부분집합과 유사
    - SQL은 영어 문자 스타일
- JSON 기반 구문을 사용
    - NoSQL 시스템이 뜻하지 않게 SQL을 모방하여 따라가고 있다.

### 그래프형 데이터모델
정점 : 노드나 엔티티라고도 한다.
간선 : 관계나 호라고도 한다.

소셜 그래프
정점은 사람이고, 간선은 사람들이 서로 알고 있음을 나타낸다.

웹 그래프
정점은 웹 페이지고 간선은 다른 페이지에서 대한 HTML 링크를 나타낸다.

도로나 철도 네트워크
정점은 교차로이고 간선은 교차로 간 도로나 철로 선을 나타낸다.

자동차 내비게이션 시스템은 도로 네트워크에서 두 지점 간 최단 경로를 검색하고 페이지랭크는 웹 그래프를 사용해 웹 페이지의 인기와 검색 결과에서 순위를 결정할 수 있다.

![[Pasted image 20240123071657.png]]


#### 속성 그래프모델
종류
- 네오포제이
- 타이탄
- 인피니티그래프

정점은 다음과 같은 요소로 구성된다.
- 고유한 식별자
- 유출 간선 집합
- 유입 간선 집합
- 속성 컬렉션 (키-값 쌍)

간선은 다음과 같은 요소로 구성된다.
- 고유한 식별자
- 간선이 시작하는 정점 (꼬리정점)
- 간선이 끝나는 정점 (머리정점)
- 두 정점 간 관계 유형을 설명하는 레이블
- 속성 컬렉션 (키-값쌍)
```SQL
CREATE TABLE vertices (
	vertex_id integer PRIMARY KEY,
	properties json
)

CREATE TABLE edges (
	edge_id integer PRIMARY KEY,
	tail_vertex integer REFERENCES vertices (vertexid),
	haed_vertex integer REFERENCES vertices (vertexid),
	label text,
	properties json
)

CREATE INDEX edges_tails ON edges (tail_vertex);
CREATE INDEX edges_heads ON edges (head_vertex);
```

1. 정점은 다른 정점과 간선으로 연결된다. 특정 유형과 관련 여부를 제한하는 스키마는 없다.
2. 정점이 주어지면 정점의 유입과 유출 간선을 효율적으로 찾을 수 있고 그래프를 순회할 수 있다. 즉 일련의 정점을 따라 앞뒤 방향으로 순회한다(예제 2-2에서 tail_vertex와 head_vertex 칼럼에 대해 색인을 생성하는 이유다)
3. 다른 유형의 관계에 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있다.

#### 트리플 저장소 모델
종류
- 데이토믹
- 알레그로그래프

### 사이퍼 질의 언어
속성 그래프를 위한 선언형 질의 언어
- 네오포제이 그래프 데이터베이스용으로 만들어졌다.

```
CREATE
	(NAmerica:Location {name: 'North America', type: 'continent'}),
	(USA:Location {name: 'United States', type: 'county'}),
	(Idaho:Location {name: 'Idaho', type: 'state'}),
	(Lucy:Person {name:'Lucy'}),
	(Idaho) -[:WITHIN]-> (USA) -[:WITHIN]-> (NAmerica),
	(Lucy) -[:BORN_IN]-> (Idaho)
```

4개의 정점을 만든다.
- Location 의 NAmerica, USA, Idaho
- Person의 Lucy

관계를 2 표현식을 통해서 진행하였다
- Idaho는 USA 에 포함이 된다, USA 는 NAmerica에 포함된다 (WITHIN)
- Lucy는 Idaho 에 태어난다. (BORN_IN)

- 중간에 있는 것들은 간선의 이름이며, 이를 토대로 Query문이 작성이 된다.

```
MATCH
	(person) -[:BORN_IN]-> () -[:WITHIN*0..]-> (us:Location {name: 'United States'}),
	(person) -[:LIVES_IN]-> () -[:WITHIN*0..]-> (eu:Location {name: 'Europe'})
```

1. person은 어떤 정점을 향하는 BORN_IN 유출 간선을 가진다. 이 정점에서 name 속성이 "United States"인 Location 유형의 정점에 도달할 때까지 일련의 WITHIN 유출 간선을 따라간다.
2. 같은 person 정점은 LIVES_IN 유출 간선도 가진다. 이 간선과 WITHIN 유출 간선을 따라가면 결국 name 속성이 "Europe"인 Location 유형의 정점에 도달하게 된다.

### 트리플 저정소와 스파클
트리플 저장소에서는 모든 정보를 주어, 서술어, 목적어처럼 매우 간단한 세 부분 구문 형식으로 저장한다.
1. 문자열이나 숫자 같은 원시 데이터타입의 값. 이 경우 트리플의 서술어와 목적어는 주어 정점에서 속성의 키, 값과 동등하다. 예를 들어 (루시, 나이, 33)은 {"age": 33} 속성을 가진 정점 lucy와 같다.
2. 그래프의 다른 정점. 이 경우 서술어는 그래프의 간선이고 주어는 꼬리 정점이며 목적어는 머리 정점이다. 예를 들어 (루시, 결혼하다. 알랭)에서 주어와 목적어인 루시와 알랭은 모두 정점이고 서술어 결혼하다는 두 정점을 잇는 간선의 레이블이다.

### 시맨틱 웹
기본적으로 간단하고 합리적인 개념이다.
- 웹 사이트는 이미 사람이 읽을 수 있는 텍스트와 그림으로 정보를 게시하고 있으니 컴퓨터가 읽게끔 기계가 판독 가능한 데이터로도 정보를 게시하는건 어떨까하는 개념이다.

### RDF 데이터 모델
자원 기술 프레임워크
서로 다른 웹 사이트가 일관된 형식으로 데이터를 게시하기 위한 방법을 제안
서로 다른 웹 사이트가 일종의 전 인터넷 만물데이터베이스인 데이터웹에 자동으로 결함할 수 있게 한다.

터틀언어
- RDF 데이터를 사람이 읽을 수 있는 형식으로 표현한다.

XML 형식으로 쓰기도 한다.

### 스파클 질의 언어
RDF 데이터 모델을 사용한 트리플 저장소 질의 언어다.

### 초석: 데이터로그
스파클이나 사이퍼보다 훨씬 오래된 언어로 1980년대 학계에서 광범위하게 연구되었다.
질의 언어의 기반이 되는 초석을 제공하기 때문

실제로 일부 데이터 시스템에서 데이터로그를 사용한다.
- 데이토믹 : 데이터로그를 질의 언어로 사용
- 캐스캘로그 : 데이터로그의 구현체로서 하둡의 대용량 데이터셋에 질의를 위한 용도

(주어, 서술어, 목적어)로 트리플을 작성하는 대신 서술어(주어, 목적어)로 작성한다.

```
name(namerica, 'North America).
type(name, continent).

name(usa, 'United States').
type(usa, country).
within(usa, namerica).

name(idaho, 'Idaho').
type(idaho, state).
within(idaho, usa).

name(lucy, 'Lucy').
born_in(lucy, idaho).
```

```
within_recursive(Location, Name) :- name(Location, Name).

within_recursive(Location, Name) :- with(Location, Via),
									within_recursive(Via, Name).

migrated(Name, BornIn, LiviingIn) :- name(Person, Name),
									born_in(Person, BornLoc),
									within_recursive(BornLoc, BornIn),
									lives_in(Person, LivingLoc),
									within_recursive(LivingLoc, LivingIn).

?- migrated(Who, 'United States', 'Europe').
```

1. 데이터베이스에 name(namerica, 'North America')가 존재하면 규칙 1을 적용한다. 규칙 1은 within_recursive(namerica, 'North America')를 생성한다.
2. 데이터베이스에 within(usa, namerica)가 존재하고 이전 단계에서 within_recursive(namerica, 'North America')를 생성했으면 규칙 2를 적용한다. 규칙 2는 within_recursive(usa, 'North America')를 생성한다.
3. 데이터베이스에 within(idaho, usa)가 존재하고 이전 단계에서 within_recursive(usa, 'North America')를 생성했으면 규칙 2를 적용한다. 규칙 2는 within_recursive(idaho, 'North America')를 생성한다.