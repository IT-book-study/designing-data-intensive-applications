# 01장 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

오늘날 많은 애플리케이션은 계산 중심과 다르게 `데이터 중심적`이다.  
많은 애플리케이션은 다음을 필요로 한다.  
- 데이터베이스
- 캐시
- 검색 색인
- 스트림 처리
- 일괄 처리(batch)

애플리케이션을 만들 때 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 한다.

## 데이터 시스템에 대한 생각

새로운 도구들은 다양한 사용사례에 최적화됐기 때문에 더 이상 전통적인 분류에 딱 들어맞지 않는다.  
ex) 메시지 큐로 사용하는 레디스, DB처럼 지속성을 보장하는 MQ 카프카 등

단일 도구로는 더 이상 데이터 처리와 저장을 모두 만족시킬 수 없는 요구사항(도전과제?)이 생겼다.  

대신 작업은 단일 도구에서 효율적으로 수행할 수 있는 태스크로 나누고 다양한 도구들은 애플리케이션 코드를 이용해서 서로 연결한다.  

![image](https://github.com/IT-book-study/designing-data-intensive-applications/assets/81370558/347147e7-32fc-4d97-a343-02e1a0049e71)

이 책에서는 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점을 둔다.
- 신뢰성
  - 결함, 오류에 직면하더라도 시스템은 지속적으로 올바르게 동작해야 한다.
- 확장성
  - 시스템 데이터의 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.
- 유지보수성
  - 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.
 
## 신뢰성

소프트웨어의 경우 일반적인 기대치는 다음과 같다.
- 애플리케이션은 사용자가 기대한 기능을 수행한다
- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다
- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
- 시스템은 허가되지 않은 접근과 오남용을 방지한다.

즉, 신뢰성의 의미는 무언가 잘못되더라도 지속적으로 올바르게 동작한다고 이해할 수 있겠다.

무언가 잘못될 수 있는 일을 결함이라고 하는데, 결함은 장애와 동일하지 않다.  
결함: 사양에서 벗어난 시스템의 한 구성요소로 정의  
장애: 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우  

예방책이 해결책보다 더 좋은 경우는 보안 문제이다. 하지만 책에서 설명하고자 하는 것은 해결책이 있는 결함 유형이다.

### 하드웨어 결함

하드웨어의 결함은 늘상 일어나는 일(이라도 한다)  
시스템 장애율을 줄이기 위한 대응 중 하나로 각 하드웨어 구성 요소에 중복을 추가하는 방법이 있다.  
구성 요소 하나가 죽으면 고장 난 구성 요소가 교체되는 동안 중복된 구성 요소를 대신 사용할 수 있다.

### 소프트웨어 오류

시스템 내 체계적 오류가 있을 수 있는데, 이 결함은 예상하기 어렵다. 또한 노드 간 상관관계 때문에 상관관계 없는 하드웨어 결함보다 오히려 시스템 오류를 더 많이 유발하는 경향이 있다.

ex) 공유 자원을 과도하게 사용하는 일부 프로세스, 시스템의 속도가 느려저 잘못된 응답을 하는 서비스, 작은 결함이 더 큰 결함을 발생시키는 연쇄 장애 등

소프트웨어의 체계적 오류 문제는 신속한 해결책이 없다.  
문제 해결에 도움을 줄 수 있는 일들은 아래와 같다.  
- 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기
- 빈틈없는 테스트, 프로세스 격리
- 죽은 프로세스의 재시작 허용
- 프로덕션 환경에서 시스템 동작의 측정
- 모니터링
- 분석하기

### 인적 오류

대규모 서비스에 대한 한 연구에 따르면 운영자의 설정 오류가 중단의 주요 원인이라고 한다. (하드웨어 결함은 10~25%)

신뢰성있는 서비스를 만드는 방법(?)
- 오류의 가능성을 최소화하는 방향으로 시스템 설계
- 사람의 실수로 장애가 발생할 수 있는 부분 분리
- 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트
- 인적 오류를 빠르고 쉽게 복구할 수 있게 하라
- 상세하고 명확한 모니터링 대책 마련(문제가 발생했을 때 지표는 문제를 분석하는 데 매우 중요)
- 조작 교육과 실습을 시행

## 신뢰성은 얼마나 중요할까?

비즈니스 애플리케이션 버그는 생산성 저하의 원인  
전자 상거래 사이트의 중단은 매출 손실 발생, 명성에 타격을 준다

즉, 큰 비용이 든다. 조심하자...

## 확장성

성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가이다.  
시스템은 전에 처리했던 양보다 더 많은 데이터를 처리하고 있을 것이다.

### 부하 기술하기

부하는 부하 매개변수라 부르는 몇 개의 숫자로 나타낼 수 있다.
- 웹 서버의 초당 요청 수
- DB 읽기 쓰기 비율
- 동시 활성 사용자
- 캐시 적중률

등이 있다.

이 책에서 소개하는 예시가 있는데, 트위터의 확장성 문제는 트윗의 양이 아닌 팬 아웃(하나의 수신 요청을 처리하는 데 필요한 다른 서비스의 요청 수를 의미)이다.  

두가지 방법을 소개하고 있는데, 아래와 같다.

1-1. 트윗을 작성하면 DB에 저장한다.  
1-2. 사용자가 타임라인을 요청하면 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간순으로 정렬해 합친다.  

![image](https://github.com/IT-book-study/designing-data-intensive-applications/assets/81370558/948c85e6-4a91-4526-89cf-4eb6e2cbac76)

2-1. 각 수신 사용자용 트윗 우편함처럼 개별 홈 타임라인 캐시를 유지한다.
2-2. 트윗을 작성하면 해당 사용자를 팔로우하는 사람을 모두 찾고 팔로워 각자의 홈 타임라인 캐시에 새로운 트윗을 삽입

![image](https://github.com/IT-book-study/designing-data-intensive-applications/assets/81370558/24463a13-273f-4a4d-9de0-10de28a5c7aa)

![image](https://github.com/IT-book-study/designing-data-intensive-applications/assets/81370558/97a08141-1fee-4a66-bcc1-90c18b857a68)

트위터는 1번 방법에서 2번 방법으로 전환했는데, 이유는 트윗 게시 요청량이 홈 타임라인 읽기 요청량에 비해 수백배 적기 때문이라고 한다.  
이 경우에는 쓰기 시점에 더 많은 일을 하고, 읽기 시점에 적은 일을 하는 것이 바람직하다.  

해당 사례에서는 `사용자당 팔로워의 분포`가 핵심 부하 매개변수이다.

**여기서 예외가 있는데, 팔로워 수가 매우 많은 소수의 사용자는 팬 아웃에서 제외된다.**

### 성능 기술하기

시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 알 수 있다.

일괄 처리 시스템은 보통 처리량(throughput), 온라인 시스템에서 더 중요한 사항은 서비스 응답시간이다.  
응답시간은 단일 숫자가 아니라 측정 가능한 값의 분포로 생각해야 한다.  
대부분의 요청은 꽤 빠르지만 가끔 꽤 오래 걸리는 특이 값이 있다.  
다양한 원인으로 추가 지연이 생길 수 있는데, 그 원인은 아래와 같다.  
- 컨텍스트 스위치
- 패킷손실 TCP 재전송
- stop the world
- 페이지 폴트(디스크 읽기를 강제) 등

![image](https://github.com/IT-book-study/designing-data-intensive-applications/assets/81370558/0e1bfcae-d1db-40e8-8943-8fb20682d488)

평균 응답시간을 알고 싶다면 산술 평균이 아닌 백분위를 사용하는 편이 좋다.  
특이 값이 얼마나 좋지 않은지 알아보려면 상위 백분위를 살펴보는게 좋은데, 이때 사용하는 백분위는 95분위(95p), 99분위(99p), 99.9(999p)분위가 일반적이다.  

꼬리 지연 시간으로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요하다. 보통 응답시간이 가장 느린 요청을 경험한 고객들이 많은 구매를 해서 고객 중 계정에 가장 많은 데이터를 갖고 있어서다.  
이들을 행복하게 해줘야 매출도 오른다.  

백분위는 서비스 수준 목표와 서비스 수준 협약서에 자주 사용하며, 기대 성능과 서비스 가용성을 정의하는 계약서에도 자주 등장한다.

큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지한다.  
소수의 느린 요청 처리반으로도 후속 요청 처리가 지체된다. 이 현상을 `선두 차단`이라고 한다.

> 병렬로 호출해도 최종 사용자 요청은 여전히 병렬 호출 중 가장 느린 호출이 완료되길 기다려야 한다. 하나의 호출만으로도 전체 최종 사용자의 요청을 느리게 할 수 있다.
> 그래서 최종 사용자 요청 중 많은 비율의 응답 시간이 결국 느려진다. 이 효과를 `꼬리 지연 증폭`이라고 한다.

![image](https://github.com/IT-book-study/designing-data-intensive-applications/assets/81370558/187506d3-5af3-4aae-b351-728d39c4883b)

### 부하 대응 접근 방식

부하 매개변수가 어느 정도 증가하더라도 좋은 성능을 유지하려면 어떻게 해야할까?

사람들은 확장성과 관련해 scailing up과 scaling out을 말하고, 다수의 장비에 부하를 분산하는 아키텍처를 비공유 아키텍처라고 한다.

적절한 사양의 장비를 여러대 사용하는게 저렴하고 간단하다~

일부 시스템은 탄력적인데, 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다. 그렇지 않은 시스템은 수동으로 확장해야 한다.  
탄력적인 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용.  
수동으로 확장하는 시스템은 간단하고 운영상 예상치 못한 일이 적다.

????
다수의 장비에 상태 비저장 서비스를 배포하는 일은 상당히 간단하다. 하지만 단일 노드에 상태 유지 데이터 시스템을 분산 설치하는 일은 일은 아주 많은 복잡도가 추가적으로 발행한다. 이런 이유로 확장 비용이나 데이터베이스를 분산으로 만들어야 하는 고가용성 요구가 있을 때 까지 단일 노드에 데이터베이스를 유지하는 것이 최근까지의 통념이다.

대규모로 동작하는 시스템의 아키텍쳐는 해당 시스템을 사용하는 애플리케이션에 특화돼 있다. 아키텍처를 결정하는 요소는 아래와 같다.
- 읽기의 양
- 쓰기의 양
- 저장할 데이터의 양
- 데이터의 복잡도
- 응답 시간 요구사항
- 접근 패턴 등

특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축하는데, 이 가정은 곧 부하 매개변수가 된다.  
이 가정이 잘못되면 확장에 대한 엔지니어링 노력은 헛수고가 되고 최악의 경우 역효과를 낳는다.


## 유지보수성

스프트웨어 비용의 대부분은 초기 개발이 아닌, 지속해서 이어지는 유지보수에 들어간다.  
유지보수에는 버그픽스, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적용, 새 사용 사례를 위한 변경, 기술부채 상환, 새 피쳐 추가 등이 있다.

레가시를 직접 만들지 않게 끔 소프트웨어를 설계할 수 있는데(!) 그러기 위해 주의를 기울여야 할 소프트웨어 시스템 설계 원칙은 다음 세가지이다.

- 운용성
  - 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라
- 단순성
  - 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라
- 발전성
  - 엔지니어가 이후 시스템을 쉽게 변경할 수 있게 하라

이 세가지를 염두해 두고 시스템을 생각하려 노력해야 한다!


### 운용성: 운영의 편리함 만들기

좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다.  
자동화를 처름 설정하고 제대로 동작하는지 확인하는 일은 여전히 사람의 몫이다.  


### 단순성: 복잡도 관리

복잡도는 같은 시스템에서 작업해야 하는 모든 사람의 진행을 느리게 하고 낙아가 유지보수 비용이 증가한다. 복잡도 수렁에 빠진 소프트웨어를 칭하는 말 == `커다란 진흙덩어리`

상태 공간의 급증, 모듈 간 강한 커플링, 복잡한 의존성, 일관성 없는 명명, 성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례 등 복잡도가 발생한다.

복잡한 소프트웨어에서 변경이 있을 때 버그가 생길 위험이 더 크다. 개발자가 시스템을 이해하고 추론하기 어려워지면 시스템에 숨겨진 가정과 의도치 않은 결과 및 예기치 않은 상호작용을 간과하기 쉽다.  
**단순성이 구축하려는 시스템의 핵심 목표여야 한다.**  

단순하게 만든다는건 우발적 복잡도를 줄인다는 뜻일지도?

우발적 복잡도를 제거하기 위한 최상의 도구는 추상화다. 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.

하지만 좋은 추상화를 찾기는 매우 어렵다.  
이런 추상화는 큰 시스템의 일부를 잘 정의되고 재사용 가능한 구성 요소로 추출할 수 있게 한다.


### 발전성: 변화를 쉽게 만들기

조직 프로세스 측면에서 애자일 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공한다.  
애자일 커뮤니티는 TDD와 리팩토링과 같은 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이 되는 기술 도구와 패턴을 개발한다.  
