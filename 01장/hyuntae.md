# 01장 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

오늘날 많은 애플리케이션은 계산 중심과 다르게 `데이터 중심적`이다.  
많은 애플리케이션은 다음을 필요로 한다.  
- 데이터베이스
- 캐시
- 검색 색인
- 스트림 처리
- 일괄 처리(batch)

애플리케이션을 만들 때 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 한다.

## 데이터 시스템에 대한 생각

새로운 도구들은 다양한 사용사례에 최적화됐기 때문에 더 이상 전통적인 분류에 딱 들어맞지 않는다.  
ex) 메시지 큐로 사용하는 레디스, DB처럼 지속성을 보장하는 MQ 카프카 등

단일 도구로는 더 이상 데이터 처리와 저장을 모두 만족시킬 수 없는 요구사항(도전과제?)이 생겼다.  

대신 작업은 단일 도구에서 효율적으로 수행할 수 있는 태스크로 나누고 다양한 도구들은 애플리케이션 코드를 이용해서 서로 연결한다.  

![image](https://github.com/IT-book-study/designing-data-intensive-applications/assets/81370558/347147e7-32fc-4d97-a343-02e1a0049e71)

이 책에서는 대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사에 중점을 둔다.
- 신뢰성
  - 결함, 오류에 직면하더라도 시스템은 지속적으로 올바르게 동작해야 한다.
- 확장성
  - 시스템 데이터의 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.
- 유지보수성
  - 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.
 
## 신뢰성

소프트웨어의 경우 일반적인 기대치는 다음과 같다.
- 애플리케이션은 사용자가 기대한 기능을 수행한다
- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다
- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
- 시스템은 허가되지 않은 접근과 오남용을 방지한다.

즉, 신뢰성의 의미는 무언가 잘못되더라도 지속적으로 올바르게 동작한다고 이해할 수 있겠다.

무언가 잘못될 수 있는 일을 결함이라고 하는데, 결함은 장애와 동일하지 않다.  
결함: 사양에서 벗어난 시스템의 한 구성요소로 정의  
장애: 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우  

예방책이 해결책보다 더 좋은 경우는 보안 문제이다. 하지만 책에서 설명하고자 하는 것은 해결책이 있는 결함 유형이다.

### 하드웨어 결함

하드웨어의 결함은 늘상 일어나는 일(이라도 한다)  
시스템 장애율을 줄이기 위한 대응 중 하나로 각 하드웨어 구성 요소에 중복을 추가하는 방법이 있다.  
구성 요소 하나가 죽으면 고장 난 구성 요소가 교체되는 동안 중복된 구성 요소를 대신 사용할 수 있다.

### 소프트웨어 오류

시스템 내 체계적 오류가 있을 수 있는데, 이 결함은 예상하기 어렵다. 또한 노드 간 상관관계 때문에 상관관계 없는 하드웨어 결함보다 오히려 시스템 오류를 더 많이 유발하는 경향이 있다.

ex) 공유 자원을 과도하게 사용하는 일부 프로세스, 시스템의 속도가 느려저 잘못된 응답을 하는 서비스, 작은 결함이 더 큰 결함을 발생시키는 연쇄 장애 등

소프트웨어의 체계적 오류 문제는 신속한 해결책이 없다.  
문제 해결에 도움을 줄 수 있는 일들은 아래와 같다.  
- 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기
- 빈틈없는 테스트, 프로세스 격리
- 죽은 프로세스의 재시작 허용
- 프로덕션 환경에서 시스템 동작의 측정
- 모니터링
- 분석하기

### 인적 오류

대규모 서비스에 대한 한 연구에 따르면 운영자의 설정 오류가 중단의 주요 원인이라고 한다. (하드웨어 결함은 10~25%)

신뢰성있는 서비스를 만드는 방법(?)
- 오류의 가능성을 최소화하는 방향으로 시스템 설계
- 사람의 실수로 장애가 발생할 수 있는 부분 분리
- 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트
- 인적 오류를 빠르고 쉽게 복구할 수 있게 하라
- 상세하고 명확한 모니터링 대책 마련(문제가 발생했을 때 지표는 문제를 분석하는 데 매우 중요)
- 조작 교육과 실습을 시행

## 신뢰성은 얼마나 중요할까?

비즈니스 애플리케이션 버그는 생산성 저하의 원인  
전자 상거래 사이트의 중단은 매출 손실 발생, 명성에 타격을 준다

즉, 큰 비용이 든다. 조심하자...

## 확장성

성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가이다.  
시스템은 전에 처리했던 양보다 더 많은 데이터를 처리하고 있을 것이다.

### 부하 기술하기

부하는 부하 매개변수라 부르는 몇 개의 숫자로 나타낼 수 있다.
- 웹 서버의 초당 요청 수
- DB 읽기 쓰기 비율
- 동시 활성 사용자
- 캐시 적중률

등이 있다.

이 책에서 소개하는 예시가 있는데, 트위터의 확장성 문제는 트윗의 양이 아닌 팬 아웃(하나의 수신 요청을 처리하는 데 필요한 다른 서비스의 요청 수를 의미)이다.  

두가지 방법을 소개하고 있는데, 아래와 같다.

1-1. 트윗을 작성하면 DB에 저장한다.  
1-2. 사용자가 타임라인을 요청하면 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간순으로 정렬해 합친다.  

![image](https://github.com/IT-book-study/designing-data-intensive-applications/assets/81370558/948c85e6-4a91-4526-89cf-4eb6e2cbac76)

2-1. 각 수신 사용자용 트윗 우편함처럼 개별 홈 타임라인 캐시를 유지한다.
2-2. 트윗을 작성하면 해당 사용자를 팔로우하는 사람을 모두 찾고 팔로워 각자의 홈 타임라인 캐시에 새로운 트윗을 삽입

![image](https://github.com/IT-book-study/designing-data-intensive-applications/assets/81370558/24463a13-273f-4a4d-9de0-10de28a5c7aa)

![image](https://github.com/IT-book-study/designing-data-intensive-applications/assets/81370558/97a08141-1fee-4a66-bcc1-90c18b857a68)

트위터는 1번 방법에서 2번 방법으로 전환했는데, 이유는 트윗 게시 요청량이 홈 타임라인 읽기 요청량에 비해 수백배 적기 때문이라고 한다.  
이 경우에는 쓰기 시점에 더 많은 일을 하고, 읽기 시점에 적은 일을 하는 것이 바람직하다.  

해당 사례에서는 `사용자당 팔로워의 분포`가 핵심 부하 매개변수이다.

**여기서 예외가 있는데, 팔로워 수가 매우 많은 소수의 사용자는 팬 아웃에서 제외된다.**

### 성능 기술하기

시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 알 수 있다.

일괄 처리 시스템은 보통 처리량(throughput), 온라인 시스템에서 더 중요한 사항은 서비스 응답시간이다.  
응답시간은 단일 숫자가 아니라 측정 가능한 값의 분포로 생각해야 한다.  
대부분의 요청은 꽤 빠르지만 가끔 꽤 오래 걸리는 특이 값이 있다.  
다양한 원인으로 추가 지연이 생길 수 있는데, 그 원인은 아래와 같다.  
- 컨텍스트 스위치
- 패킷손실 TCP 재전송
- stop the world
- 페이지 폴트(디스크 읽기를 강제) 등

// 14P 마지막 문단부터 ㄱㄱ





















