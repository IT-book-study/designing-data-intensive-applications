애플리케이션이 요구하는 조건
- 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장 (데이터베이스)
- 읽기 속도 향상을 위해 값비싼 수행 결과를 기억 (캐시)
- 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공 (검색 색인(search Index))
- 비동기 처리를 윟른 프른 프로세스로 메시지를 보내기 (스트림 처리 (stream processing))
- 주기적으로 대량의 누적된 데이터를 분석(일괄 처리(batch processing))

대부분의 엔지니어들은 처음부터 새로운 데이터 저장소 엔진을 작성하는 모습을 상상하지 않음.
-> 데이터베이스가 데이터 저장 작업을 위해 더할 나위 없이 좋은 도구이기 때문.
ME) 나 또한 이 의견에 대해서 이견이 없을 정도

## 데이터 시스템에 대한 생각
1. 데이터 저장과 처리를 위한 여러 새로운 도구는 최근에 만들어졌다.
   새로운 도구들은 다양한 사용 사례에 최적화됐기 때문에 더 이상 전통적인 분류에 딱 들어맞지 않는다.
2.  더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 갖고 잇다.
    작업은 단일도구에서 효율적으로 **수행할 수 있는 태스크**로 나누고 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결한다.

### 소프트웨어 시스템에서 중요하게 여기는 세가지 관심사.
#### 신뢰성
하드웨어나 소프웨어 결함, 심지어 인적 오류(human error) 같은 역경에 직면하더라도 시스템은 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야 한다.

소프트웨어가 가지는 일반적인 기대치
- 애플리케이션은 사용자가 기대한 기능을 수행한다.
- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.
- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
- 시스템은 허가되지 않은 접근과 오남용을 방지한다.

결함
잘못될 수 있는 일, 사양에서 벗어난 시스템의 한 구성 요소로 정의
결함 확률을 0으로 줄이는 것은 불가능 -> 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 가장 좋다.
내결함성 || 탄력성 :  **특정 유형의** 결함을 예측하고 대처할 수 있는 시스템.
장애 : 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈추는 것.
**결함 != 장애**

##### 하드웨어 결함
각 하드웨어 구성 요소에 중복을 추가
Raid 구성으로 설치할 수 있고 서버는 이중 전원 디바시으솨 핫스왑 가능한 cpu, 데이터센터는 건전지와 예비 전원용 디젤 전기를 갖출 수 있다.

ME) G모사도 Raid와 fail over에 대응을 하였지만 테스트가 미흡하여 큰 장애를 경험했었지.
장비 신뢰성보다는 유연성(flexibility)과 탄력성(elasticity)을 우선적으로 처리하게끔 설계를 했다.
##### 소프트웨어 오류
- 잘못도니 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그, 예를 들어 리눅스 커널의 버그로 인해 많은 애플리케이션이 일제히 멈춰버린 원인이 된 [[2012년 6월 30일 윤초]]를 생각해보자.
- CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭처럼 공유 자원을 과도하게 사용하는 일부 프로세스.
- 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
- 한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애

##### 인적 오류
- 오류의 가능성을 최소화하는 방향으로 시스템을 설계하라
- 사람이 가장 많이 실수하는 장소(부분)에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리하라.
    - 실제 데이터를 사용해 안전하게 살펴보고 실험할 수 있지만 실제 사용자에게 영향이 없는 비 프로덕션 샌드박스를 제공하라. -> dev / stg 환경
- 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트하라.
    - 코너케이스 : 정상적인 동작에서 거의 발생하지 않는 경우
- 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르게 쉽게 복구할 수 있게 하라.
- 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라.
    - 원격 측정
- 조작 교육과 실습을 시행하라

#### 확장성
시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야한다.

증가한 부하에 대처하는 시스템 능력을 설명하는데 사용하는 용어
시스템에 부여하는 **일차원적인 표식이 아님**을 주의
현재 부하를 **간결하게 기술**해야한다.

부하 매개변수
- 웹 서버의 초당 요청수.
- 데이터베이스의 읽기 대 쓰기 비율
- 대화방의 동시 활성 사용자
- 캐시 적중률

![Pasted image 20240116141907.png](resource%2FPasted%20image%2020240116141907.png)

새로운 트위터가 작성이 되면, 모든 트위터 내용이 담기는 tweets 테이블에 저장을 한다.
- 쓰기 비용은 1회만 사용되므로 적게 사용 된다.

사용자가 본인의 홈 타임라인을 요청하게 되면, join 문을 통해 보여져야하는 내용을 취합한다.
- 간단하게 예제에 3개의 테이블이 사용되었고, 매 유저마다 해당 쿼리가 수행이 된다. -> 고비용

![Pasted image 20240116141853.png](resource%2FPasted%20image%2020240116141853.png)

각 유저들은 Cache를 통해 홈 타임라인을 유지한다.
- 사용자가 트윗을 작성하면, 자신의 팔로우하고 있는 모든 유저들에게 정보를 전파하고 Cache에 데이터를 기록한다. -> 1회 Write 될 정보가 각 user로 늘어났기때문에 쓰기 비용이 증가하였다.
- Select 하는 비용은 각각 Cache 를 들고 있기때문에 비용이 저렴한다.

##### 성능 기술하기
1. 부하 매개변수를 증사시키고 시스템 자원 (CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?

2. 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원하다면 얼마나 많은 자원을 늘려야할까?

> 지연시간과 응답시간
> 응답시간 : 클라이언트 관점
> 	요청을 처리하는 실제시간(서비스시간) + 네트워크 지연 시간 + 큐 지연 시간
> 지연시간 : 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지상태인 시간

평균 응답 시간 : 산술 평균을 의미하며, n개 값을 모두 더하여 n으로 나눈 숫자이다.
백분위 :
중앙값 : 오름차순/내림차순 정렬을 하여 중간 지점의 값을 의미한다.

응답 시간 : 1, 5, 6, 100
평균 응답시간 : (1 + 5 + 6 + 100) / 4 = 28
중앙값 : 5 혹은 6
특이한 케이스로 인하여 하나의 응답이 확 느려졌을 경우 평균 응답시간이 매우 느리게 계산될 수 있다.
중앙값 기준으로 보았을 때 100은, 중앙값으로부터 느린 케이스의 하나로 볼 수 있다.

큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지한다.
서버는 병렬로 소수의 작업만 처리할 수 있기 때문에 소수의 느린 요청 처리만으로도 후속 요청 처리가 지체 된다. -> **선두차단**

부하 테스트
- 응답 시간과 독립적으로 요청을 지속적으로 보내야한다.
- 클라이언트가 다음 요청을 보내기 전에 이전 요청이 완료되길 기다리면 테스트에서 인위적으로 대기 시간을 실제보다 더 짧게 만들어 평가를 왜곡한다.
    - TPS - 초당 처리할 수 있는 처리량
    - 1초당 n개의 Trasaction을 발생하여 성공 여부 및 응답시간을 기록을 한다. 이후 중앙값을 통하여 해당 서버의 평균 tps 를 기록한다.

Scaling up
스케일 업. 자원의 용량을 늘린다. 수직 확장이라고 부른다.
**탄력적**으로 운영할 수 있다. 특정한 트래픽에 도달하면 시스템은 자동으로 자원을 늘린다.
Scaling out
스케일 아웃. 동일한 시스템을 여러대로 복사하여 분산처리를 꽤한다.

비공유 아키텍처 : 다수의 장비에 부하를 분산하는 아키텍처. 스케일아웃에 용이하다
#### 유지보수성
시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업(유지보수하고 새로운 사용 사례를 시스템에 적용하는 엔지니어링과 운영) 할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야한다.

##### 운용성
운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만드는 것
##### 단순성
시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만드는 것
- 사용자 인터페이스의 단순성과는 다르다는 점에 유의하라.

**추상화**
- 깔금하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.
- 좋은 추상화는 다른 다양한 애플리케이션에서도 사용 가능하다.
- 재사용은 비슷한 기능을 재구현하는 것보다 더 효율적일 뿐만 아니라 고품질 소프트웨어로 이어진다.
##### 발전성
엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 만드는 것
- 유연성, 수정 가능성, 적응성으로 알려져있다.