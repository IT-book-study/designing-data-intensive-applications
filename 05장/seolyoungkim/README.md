# Introduction
## 복제란 
- 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미 

### 필요한 이유 
- 지리적으로 가깝게 데이터를 유지 → Latency 감소
- 일부에 장애가 발생해도 다른 장비로 서비스 제공 → 고가용성
- 읽기 부하를 분산 → 읽기 Throughput 증가

### 데이터셋 크기
- 크기가 작은 경우 전체 데이터셋의 복사본 보유 가능
- 크기가 큰 경우 일부만 복사본 보유 가능
  - 파티셔닝(샤딩) 필요 

### 복제가 어려운 이유 
- 데이터가 변경되면 모든 복사본을 변경해야 하기 때문 
- 노드 간 변경 복제 알고리즘
  - Single-leader, Multi-leader, Leaderless

### Trade-off
- 동기식 vs 비동기식
- 잘못된 복제본을 처리하는 방법 
- 최종적 일관성 
- read-your-writes, monotonic reads...

---

---

# Leader & Follower
- 복제 서버(replica)
  - DB 복사본을 저장하는 각 노드
- 모든 복제 서버에 동일한 데이터가 있다는 사실을 어떻게 보장할까?
  - 모든 쓰기는 모든 복제 서버에서 처리해야 함
    - Leader-based replication
    - 복제 서버 중 하나를 Leader로 지정 
    - DB 쓰기 발생 시, Leader에게 전달
    - Local 저장소에 기록 
    - Replication log나 Change stream의 일부로 Followers에게 전달
    - 로그를 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용하여 갱신 
  - 읽기는 아무데나 보내도됨 


## 동기식 vs 비동기식 
![img.png](img.png)

### 동기식 복제
- 팔로워가 쓰기를 수신했는지 확인 후 응답
- 팔로워가 리더와 일관성이 있게 최신 데이터 복사본을 가지는 것을 보장 
  - 따라서, 리더가 죽어도 팔로워의 데이터를 계속 사용할 수 있음 
- 근데 팔로워가 죽어서 쓰기를 수신할 수 없는 경우 쓰기가 처리되지 못함
  - 리더는 모든 쓰기를 blocking 하고, 팔로워가 복구될 때까지 대기함

### 비동기식 복제
- 쓰기 전송 후 확인하지 않고 바로 응답
- 리더가 잘못되고 복구가 불가능한 경우, 복제되지 않은 모든 쓰기가 유실됨 
  - 클라이언트가 이미 확인을 했음에도 지속성이 보장되지 않음 
- 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속할 수 있음 

### 반동기식 복제 
- 모든 팔로워가 동기식인 상황은 매우 비현실적임 
  - 동기식 팔로워 1개, 나머지는 비동기식으로 구성 
  - 동기식 팔로워가 죽거나 느려지면 비동기식 팔로워 중 하나가 동기식이 됨 
- 결론적으로 **적어도 두 노드에 데이터의 최신 복사본이 있는 것을 보장**


## 새로운 팔로워 설정 
- 복제 서버 수를 늘리거나 장애 노드 대체 시 새로운 팔로워 설정 필요 
  - 새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 보장할 필요가 있음 
  - 신경써야 하는 것
    - 클라이언트는 계속 DB에 기록 중인 상태
    - 데이터는 유동적임
  - 파일 복사본을 사용하는 것은 다른 시점의 데이터를 볼 수 있어서 유효 결과가 아닐 수 있음 
    - 그렇다고 데이터베이스 쓰기를 막아버리고 일관성을 보장하는 것은 비현실적(고가용성 달성 불가)

### 팔로워 설정 방법
1. 전체 DB를 잠그지 않고 리더의 DB 스냅샷을 일정 시점에 가져옴
2. 스냅샷을 새로운 팔로워 노드에 복사 
3. 팔로워가 리더에 연결하여 스냅샷 이후 발생한 모든 데이터 변경을 요청
   - 스냅샷이 리더의 복제 로그의 정확한 위치를 알아야 함 
     - Postgres: Log Sequence Number 
     - MySQL: Binlog Coordinates
4. 팔로워가 스냅샷 이후 데이터 변경(backlog)을 모두 처리 (따라잡았다고 표현)
5. 복제 완료 


## 노드 중단 처리
> 리더 기반 복제의 고가용성 
> - 개별 노드의 장애(또는 리부팅)에도 전체 시스템이 동작하게끔 유지하고, 노드 중단의 영향을 최소화 하는 것이 목표

### 팔로워 장애: 따라잡기 복구
- 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관
- 팔로워가 죽거나 네트워크가 중단된 경우
  - 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 확인 
  - 리더에게 연결이 끊어진 동안 발생한 데이터 변경분을 모두 요청
  - 모두 적용되면 리더를 다 따라잡게 되고, 이전과 같이 데이터 변경 스트림을 계속 받을 수 있음

### 리더 장애: 장애 복구(fail over)
- 대략적인 과정 
  - 팔로워 중 하나를 새로운 리더로 승격 
  - 클라이언트가 새로운 리더로 쓰기를 전송할 수 있도록 재설정 
  - 다른 팔로워는 승격된 새로운 리더로부터 데이터 변경 스트림을 받게 됨

#### 자동 장애 복구 단계
1. 리더가 장애가 났는지 판단 
   - 노드들은 서로 메세지를 주고 받으며 health check를 수행
   - 일정 시간동안 응답하지 않을 경우 죽은 것으로 판단 
     - 리더를 의도적으로 중단한 경우는 타임아웃 X 
2. 새로운 리더 선출
   - 선출 과정 이용 
     - 나머지 팔로워들의 대다수에 의해 선택됨 
   - 제어 노드(controller node) 이용  
     - 이전에 선출해둔 제어 노드로 리더를 임명 
   - 리더 후보 
     - 이전 리더의 최신 데이터 변경사항을 가진 복제 서버 
3. 새로운 리더 사용을 위한 시스템 재설정
   - 쓰기 요청을 새로운 리더에게 보낼 수 있도록 재설정 
   - 이전 리더가 복구될 경우, 이전 리더를 팔로워로 만들고 새로운 리더를 인식할 수 있게끔 해야함 


#### 장애 복구 과정 시 주의해야 할 것 
- 비동기식 복제 
  - 새로운 리더가 이전 리더의 쓰기를 일부 수신하지 못할 수 있음 
  - 새로운 리더가 이전 리더와 충돌하는 쓰기를 수신했을 수도 있음 
  - 단순히 이전 리더의 쓰기를 폐기하는 방법이 있겠지만, 내구성에 대한 클라이언트 기대를 저버리게되는 꼴 
- 쓰기 폐기 
  - DB 외부의 다른 저장소 시스템이 DB 내용에 맞춰 조정되어야 할 경우 위험함 
  - ex: 유효하지 않은(out-of-date) MySQL 팔로워가 리더로 승격된 사례 
    - DB가 새로운 row의 PK를 할당하기 위해 auto-increment 값을 사용
    - 새로운 리더의 auto-increment 값은 이전 리더보다 뒤쳐져 있었음 
    - 이전 리더가 예전에 할당했던 PK를 재사용 해버림... 
    - 근데 이 PK를 레디스에도 사용함 
    - MySQL과 레디스의 데이터 불일치 발생
    - 일부 개인 데이터가 잘못된 사용자에게 공개 
- 스플릿 브레인
  - 두 노드가 모두 자신이 리더라고 믿는 상황 
  - 두 리더가 쓰기를 받으면서 충돌 해소 과정을 거치지 않으면 데이터 유실/오염 발생 
    - 두 리더가 감지되면 한 리더를 종료하는 메커니즘이 있으나, 이 또한 주의깊게 설계되어야 함 (그렇지 않으면 두 노드를 모두 종료) 
- 리더가 죽었다고 판단 가능한 적절한 타임 아웃이란?
  - 너무 짧으면 잘못된 판단이 발생할 수 있음 (불필요한 장애 복구)
    - 일시적인 부하 급증으로 인한 응답 지연
    - 네트워크 고장으로 인한 패킷 지연
    - 불필요한 장애 복구가 상황을 더 악화시킬수도... 
  - 너무 길면 장애 복구 시간이 길어짐 

## 복제 로그 구현 
### 구문(statement) 기반 복제  
- 모든 쓰기 요청(구문(statement))을 기록 
  - 구문 로그를 팔로워에게 전송
  - ex: RDBMS는 INSERT, UPDATE, DELETE 등의 SQL 구문을 팔로워에게 전달 → 각 팔로워가 이를 파싱 및 실행
- 복제가 깨질 수 있는 상황 
  - 비결정적 함수를 사용하는 경우 각 팔로워마다 다른 값을 생성할 가능성이 있음 
    - ex: NOW(), RAND() 등
  - Auto-increment나 데이터베이스에 존재하는 다른 데이터에 의존하는 경우 
    - 구문이 각 팔로워에서 정확히 같은 순서로 실행돼야 함 
  - Side effect를 가진 구문을 사용하는 경우 
    - Side effect가 결정적이지 않으면 팔로워에서 각각 다른 Side effect가 발생할 수 있음
    - ex: 트리거, 스토어드 프로시저 등
- 구문에 비결정성이 있는 경우, 다른 복제로 대체되어야 함 

### 쓰기 전 로그 배송 (WAL Shipping)
- 로그는 데이터베이스의 모든 쓰기를 포함하는 append-only 바이트열임  
  - 로그 구조화 저장소 엔진은 로그 자체가 저장소의 주요 부분 
    - 로그 세그먼트 작게 유지, 백그라운드로 GC 수행 
  - B-Tree는 개별 디스크 블록에 덮어 씀
    - 쓰기 전 로그(WAL, Write-Ahead Log)에 기록 
    - 고장 후 일관성 있는 상태로 index 복구 
- 완전히 동일한 로그를 사용하여 다른 노드에서 복제 서버를 구축 
  - 리더는 디스크에 로그를 기록할 뿐만 아니라, 팔로워에게 네트워크로 로그를 전송하기도 함 
  - 팔로워가 로그를 처리 → 리더와 동일한 데이터 구조의 복제본 생성 
- 단점
  - 로그는 제일 저수준의 데이터를 기술한다 
  - WAL은 어떤 디스크 블록에서 어떤 byte를 변경했는지와 같은 상세 정보를 포함한다 
  - 복제 로그가 저장소 엔진과 밀접하게 엮어버리게 됨 
    - 저장소 형식을 다른 버전으로 변경하게 될 경우 리더와 팔로워의 버전을 다르게 실행할 수 없음
    - 버전 업그레이드 시 중단 시간이 필요함

### 논리적(row 기반) 로그 복제 
- 복제 로그와 저장소 엔진 내부를 분리하는 방법 
- 저장소 엔진의 물리적 데이터 표현과 구별하기 위해 논리적 로그(logical log)라고 부름 
- 로그 특징  
  - 삽입된 row의 로그는 모든 컬럼의 새로운 값을 포함
  - 삭제된 row의 로그는 row를 고유하게 식별하는 데 필요한 정보를 포함 
    - 보통은 PK인데, PK가 없다면 모든 컬럼의 예전 값을 로깅해야 함 
  - 갱신된 row의 로그는 row를 고유하게 식별하는 데 필요한 정보와 모든 컬럼의 새로운 값을 포함 
- 여러 row를 수정하는 트랜잭션
  - 여러 로그 레코드 생성
  - 트랜잭션이 커밋됐음을 레코드에 표시
- 논리적 로그를 저장소 엔진 내부와 분리 
  - 하위 호환성을 더 쉽게 유지할 수 있음 
  - 리더와 팔로워에서 다른 버전의 소프트웨어나 다른 저장소 엔진 실행 가능
- 사용 예: MySQL의 binlog 

### 트리거 기반 복제 
- 복제를 애플리케이션 층에서 수행하는 방식 
  - 데이터의 서브셋만 복제하거나, DB를 다른 종류의 DB로 복제해야 하거나, 충돌 해소 로직이 필요한 경우
- 트리거나 스토어드 프로시저를 사용  
- 많은 오버헤드가 존재 
- 내장된 복제보다 버그나 제한 사항이 더 많이 발생 
- 유연성 때문에 사용하는 경우가 있음 

---

---

# 복제 지연 문제