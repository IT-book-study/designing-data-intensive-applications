# Introduction
- 이번 장에서 알아볼 것 
  - 데이터베이스가 데이터를 저장하는 방법
  - 데이터를 요청했을 때 다시 찾을 수 있는 방법
- 개발자가 "데이터베이스 저장/검색을 내부적으로 처리하는 방법"에 대한 대략적인 개념을 이해해야 하는 이유  
  - 적합한 엔진을 선택하기 위함 
  - 특정 작업 부하(work load) 유형에서 좋은 성능을 내게끔 엔진을 조정하기 위함

---

---

# 데이터베이스를 강력하게 만드는 데이터 구조 
- 많은 데이터베이스는 내부적으로 **추가 전용(append-only) 데이터 파일인 로그(log)** 를 사용함 
  - 본 도서에서의 로그의 의미 : **연속된 추가 전용 레코드**
- 인덱스(Index, 색인)
  - 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위한 **데이터 구조**
  - 어떤 부가적인 메타데이터를 유지하는 것 
  - 메타 데이터는 **이정표 역할을 해서 원하는 데이터의 위치를 찾는 데 도움**을 줌 
  - 인덱스는 기본 데이터로부터 파생된 추가적인 구조임 
    - 데이터베이스 내용에는 영향 X (물론, 인덱스 리빌드/빌드에 많은 시간이 걸릴 순 있다...)
    - 질의 성능에는 영향 O 
      - Write 과정에서 오버헤드 발생
        - 데이터 갱신 시마다 index도 갱신해야 하므로... 
      - Read는 빨라짐 
  - 인덱스를 사용하는 것은 저장소 시스템에서 아주 **중요한 트레이드오프** 사항이다. 
    - 인덱스를 잘 선택할 경우 Read 속도 향상 
    - 모든 Write 속도는 저하됨 
    - 개발자가 적절한 인덱스를 선택하는 것이 중요 (데이터베이스에 대한 이해가 수반돼야 함)


## 해시 Index
![img.png](img.png)
- Key를 데이터 파일의 byte offset에 매핑
  - 근데 그림처럼 연속으로 저장돼 있으면 앞의 value의 길이가 변할 경우 뒤의 offset도 전부 갱신되어야 하지 않나..?
- 램에 모든 Key가 저장될 수 있을 경우 고성능 Read/Write 보장 
- Key에 할당된 Value가 자주 갱신되는 상황에 적합 

### 특정 크기의 Segment로 로그 나누기 
![img_1.png](img_1.png)
![img_2.png](img_2.png)
- 파일에 항상 추가만 할 경우 디스크 공간이 부족해지므로, 특정 크기의 Segment로 로그를 나눈다
  - 세그먼트를 나눠도 같은 디스크 공간을 차지할 것 같은데, 디스크 공간이 부족해지니까 나눈다는 것은 무슨 의미일까 
  - 파일을 하나 열어두었을 때의 용량이 부족해진다는 의미일까? 파일을 닫고 새로운 세그먼트에 쓴다고 되어있으니까..?
  - 아니면 더 효율적으로 용량 관리를 수행하기 위함이려나? MySQL이 데이터 페이지 사이즈를 고정 해두고 사용하는 것 처럼..? 
- Compaction 수행 
  - 로그에서 중복된 키를 버리고, 각 키의 최신 갱신 값만 유지하는 것
  - 여러 세그먼트들을 병합할 수 있음 
    - 쓰여진 세그먼트를 변경하는 개념이 아니라(변경 불가), 새로운 병합된 세그먼트를 생성함 
  - 병합, 컴팩션은 백그라운드 스레드에서 수행
    - 수행되는 동안 이전 세그먼트 파일을 사용해 Read/Write 처리 
  - 병합 이후에는 새로 병합한 세그먼트를 사용하게끔 전환 
  - 이전 세그먼트 파일 삭제 
- 각 세그먼트들은 Key-value(byte offset) 형태의 인메모리 해시 테이블로써 사용됨 
  - 키의 값을 조회 요청 → 최신 세그먼트의 해시맵 확인 → 키가 없을 경우 두 번째 최신 세그먼트 등을 확인 
  - 병합을 통해 세그먼트 수를 적게 유지하기 때문에 많은 해시맵을 확인할 필요가 없음

### 이를 구현하기 위해 세부적으로 고려해야 하는 것들..
- 파일 형식
  - byte 형식의 문자열을 encoding한 binary format이 가장 빠르고 간단함  
- 레코드 삭제
  - key와 value를 삭제하고 싶을 때, tombstone(묘비)이라고도 불리는 특별한 삭제 레코드를 추가해야 함 
  - 세그먼트가 병합될 때 tombstone은 병합되지 않는다 
- Crash 복구 
  - DB 재시작 시 인메모리 해시맵은 손실됨 
  - 전체를 다시 복구하는 것은 오랜 시간이 걸릴 수 있으므로, 조금 더 빠르게 로딩할 수 있게 스냅숏을 디스크에 저장해두고 복구에 이용할 수 있음 
- 부분적으로 레코드 쓰기 
  - DB는 로그에 레코드를 추가하고 있는 도중에도 죽을 수 있음 (손상된 로그) 
  - 체크섬을 이용해서 로그의 손상을 탐지하고, 무시하게 할 수 있음 
- 동시성 제어 
  - 쓰기를 엄격하게 순차적으로 로그에 추가하고 싶을 때 → 하나의 Writer 스레드만 사용 
  - 다중 스레드로 동시에 읽는 것은 문제가 없다 → 세그먼트는 append-only거나 immutable하기 때문

### 추가 전용 로그는 여러 측면에서 좋은 설계임 
- 추가, 세그먼트 병합은 순차적인 쓰기 작업 
  - 무작위 쓰기보다 훨씬 빠름 
  - SSD에서도 효과가 좋음 
- 추가 전용 & 불변 
  - 동시성 제어가 간단함 
  - Crash 복구 또한 훨씬 간단함 
- 오래된 세그먼트 병합은 file system fragmentation을 피할 수 있음 
  - https://en.wikipedia.org/wiki/File_system_fragmentation
  - SSD는 랜덤액세스가 빨라서 안해도 괜찮지만, 예전의 HDD는 랜덤액세스가 느려서 성능 저하가 발생했음

### 해시 테이블 인덱스의 제한 사항 
- 메모리에 저장해야 하므로 Key가 너무 많으면 문제가 됨 
- 범위 질의(range query)에 효율적이지 않음 


## SSTable & LSM Tree
### SSTable : Sorted String Table
![img_3.png](img_3.png)
- Key-value 쌍을 key로 정렬된 순서로 저장하는 테이블
- 해시 index를 가진 로그 segment 보다 좋은 점
  - Merge sort와 유사한 방식으로 segment 병합을 수행함 
    - 각 세그먼트를 읽음 → 각 파일의 첫 번째 키를 봄 → 가장 작은 키를 출력 파일로 복사 → 반복...
      - 동일한 key를 가진 세그먼트가 있을 경우, 가장 최근 값만 유지하고 오래된 값은 버림 
    - 병합 segment 파일 생성 (key 로 정렬된 상태)
  - 파일에서 특정 키를 찾기 위해 메모리에 모든 key index를 유지할 필요가 없음
    - 정렬을 이용해 key를 찾기가 쉽다 
      - ![img_4.png](img_4.png)
      - ex: handiwork 위치를 찾기 위해 handbag을 찾고, 그 이후 부터 handiwork가 나올 때까지 스캔하면 됨
  - 레코드들을 블록으로 그룹화하고 압축해서 저장하고, index가 압축 블록의 시작을 가리키게 할 수 있다 
    - 디스크 공간 절약, I/O 대역폭 사용 감소 

### SSTable 생성 및 유지
- 데이터를 key로 정렬하려면? 
  - 유입되는 write는 임의 순서로 발생하는데..?
- 디스크 상에 정렬된 구조를 유지하는 것이 가능은 하나, **메모리에 유지하는 것이 훨씬 쉬움**
  - Red-black tree, AVL tree 등을 이용
  - 임의 순서로 키를 삽입해도 정렬된 순서로 키를 다시 읽을 수 있음
- 저장소 엔진 만들기 
  - 쓰기 기능
    - 쓰기 발생 → 인메모리 balanced tree(ex: Red-black tree)에 삽입 
      - 인메모리 트리는 memtable 이라고도 함 
  - memtable이 임곗값 이상의 용량을 차지하는 경우
    - SS table file로 디스크에 기록
      - 트리가 이미 key로 정렬된 key-value 쌍을 유지 중이기 때문에 효율적으로 수행 가능 
      - 새로운 SS table 파일은 DB의 가장 최신 segment가 됨
  - 읽기 기능 
    - 읽기 요청 발생 → memtable에서 key를 조회 → 없으면 디스크의 가장 최신 세그먼트 조회 → 없으면 이전 세그먼트 조회 → 없으면 이전 세그먼트 조회... 반복
  - 세그먼트 파일 병합, 컴팩션 기능 제공 (백그라운드에서 수행되도록)
- 문제 
  - DB고장 시, 아직 디스크로 기록되지 않았지만, 멤테이블에는 존재하는 가장 최신 데이터는 손실됨
  - 쓰기를 즉시 추가할 수 있도록, 로그/스냅숏을 디스크 상에 유지해야함

### LSM Tree : Log-Structured Merge Tree
- 카산드라, HBase에서도 유사한 저장소 엔진을 사용함 
- LSM Tree는 로그 구조화 파일 시스템의 초기 작업의 기반이 되었음
- 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라고 부름 
- Lucene
  - 엘라스틱 서치, 솔라에서 사용하는 전문 검색 index 엔진 
  - 용어 사전(term dictionary)를 저장하기 위해 유사한 방법을 사용 
  - 검색 질의로 단어가 들어옴 → 단어가 언급된 모든 문서 조회 
    - key를 단어(용어)로, value는 단어를 포함한 모든 문서의 ID List로 하는 key-value 구조로 구현 
  - Lucene에서는..
    - 용어-포스팅목록 매핑은 SS table과 같은 정렬 파일에 유지 
    - 필요에 따라 백그라운드에서 병합

### 성능 최적화 
- LSM Tree 알고리즘은 DB에 존재하지 않는 Key를 찾는 경우 느릴 수 있음 
  - Key의 존재 여부를 확인하기 까지 모든 segment를 확인해야 하기 때문 
- 이를 최적화 하기 위해 **Bloom filter**를 추가적으로 사용
  - [블룸 필터 - 위키](https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A3%B8_%ED%95%84%ED%84%B0)
    - 원소가 집합에 속하는지 여부를 검사하는 데 사용되는 확률적 자료구조 
    - **원소가 집합에 속하지 않는 것으로 판단되었을 때, 실제로 원소가 집합에 속하는 부정 오류가 절대 발생하지 않는다**는 특징이 있음 
      - 반대로, 원소가 집합에 속한다고 판단되었을 때는 실제로는 원소가 집합에 없을 수도 있음(긍정 오류) 
    - 집합에 원소 추가는 가능하나 삭제는 불가능
  - 이를 이용하면 key가 db에 존재하지 않음을 알려줌 → 존재하지 않는 키를 위한 불필요한 디스크 I/O를 줄일 수 있음
- SS Table을 압축하고 병합하는 순서와 시기를 결정하는 다양한 전략 
  - Size-tiered/leveled compaction 
    - Size-tiered compaction 
      - 상대적으로 좀 더 새롭고 작은 SS table을 상대적으로 오래됐고 큰 SS table로 병합 
    - Leveled compaction
      - key 범위를 더 작은 SS table로 나눔 
      - 오래된 데이터는 개별 level로 이동 → 점진적인 compaction 수행 → 디스크 공간 절약 
- LSM tree의 기본 개념 
  - 백그라운드에서 연쇄적으로 SS table을 지속적으로 병합하는 것 
  - 데이터 셋이 준비된 메모리 용량보다 훨씬 더 커도 효과적임  
  - 데이터가 정렬된 순서로 저장돼 있으므로 효율적인 범위 질의 수행 가능 
  - Write가 순차적이기 때문에 높은 쓰기 처리량 보장 가능 

## B-Tree
- LSM Tree Index는 가장 일반적인 Index 타입이 아님 
- 가장 널리 사용되는 구조는 `B-Tree`임 
- Key로 정렬된 Key-value pair 유지 
  - key-value 검색과 범위 질의에 효율적 
- 설계 철학이 LSM Tree와는 매우 다름 
  - LSM tree
    - DB를 수 메가바이트 이상의 가변 크기를 가진 segment로 나눔 
    - 항상 순차적으로 segment를 기록 
  - B-Tree
    - 4KB 크기(or more)의 고정 크기 **블록 또는 페이지**로 나눔 
    - 한번에 하나의 페이지에 읽기 또는 쓰기를 수행 
- 각 페이지는 주소나 위치를 이용해 식별
  - ![img_5.png](img_5.png)
  - 하나의 페이지가 다른 페이지를 참조할 수 있음 
  - 포인터와 비슷하나 메모리 대신 디스크에 있음 

### 구성 
- Root page
  - B Tree의 시작점
- 중간에 있는 page들은 여러 키와 하위 페이지의 참조를 포함 (key 범위 담당)
- Leaf page
  - 개별 Key를 포함하는 페이지 
  - 각 key의 value를 포함하거나, value를 찾을 수 있는 페이지의 참조를 포함한다

### 특징 
- branching factor (분기 계수)
  - 한 페이지에서 하위 페이지를 참조하는 수 (그림 상에서 ref의 수를 의미하는듯)
- B Tree에 존재하는 key의 값을 갱신하려면... 
  - key를 포함하고 있는 리프 페이지 검색 → 페이지 값 수정 → 페이지를 다시 디스크에 기록 
- 새로운 key를 추가하려면...
  - ![img_6.png](img_6.png)
  - 새로운 키를 포함하는 범위의 페이지 검색 → 해당 페이지에 key-value 추가 
  - 여유 공간이 없을 경우, 페이지 하나를 반쯤 채워진 페이지 둘로 분할 → 상위 페이지가 새로운 키 범위의 하위 부분들을 알 수 있게 갱신 
- 트리가 계속 **균형을 유지하는 것을 보장**
- n개의 key를 가진 B Tree는 깊이가 항상 `O(log n)`임 
  - 대부분 DB는 depth 가 3~4 정도면 충분 
    - 분기 계수 500, 4KB 페이지, 4 depth의 B Tree는 256TB의 데이터를 저장할 수 있음
  - 많은 페이지 참조를 따라가지 않아도 됨 

### 신뢰 가능한 B Tree 만들기 
- 기본적인 쓰기 동작 
  - 새로운 데이터를 디스크 상의 페이지에 덮어 씀 
  - 페이지 위치를 변경하지 않는다고 가정함 → 페이지를 가리키는 모든 참조는 온전하게 남음  
- 일부 페이지만 기록하고 DB 고장이 발생하면 Index가 훼손됨 
  - orphan page가 발생할 수 있음 
- DB가 스스로 복구할 수 있게 하려면...
  - 디스크 상에 Write-ahead log(WAL, 또는 redo log라고도 함)라고 하는 데이터 구조를 추가하여 B Tree를 구현함 
    - 트리 페이지에 변경된 내용을 적용하기 전에 모든 B 트리의 변경 사항을 기록하는 추가 전용 파일임 
    - DB가 복구될 때 일관성 있는 상태로 B Tree를 다시 복원하는 데 사용함 
- 같은 자리의 페이지를 갱신하는 작업
  - 다중 스레드가 동시에 B Tree에 접근할 경우, 주의 깊은 동시성 제어가 필요
    - 일관성이 깨진 상태의 트리에 접근하지 않도록 주의해야 함 
  - Latch로 트리 데이터 구조를 보호함  

### B Tree 최적화 
- 페이지 덮어 쓰기와 고장 복구를 위한 WAL 유지 대신 일부 데이터베이스는 copy-on-write scheme 을 사용함
  - 변경된 페이지는 다른 위치에 기록 → 트리에 상위 페이지의 새로운 버전을 생성 → 새로운 위치를 가리키게 함 
- 페이지에 전체 키를 저장하지 않고, 키를 축약해서 사용하여 공간을 절약 
  - 트리 내부 페이지에서 key가 key 범위 사이의 경계 역할을 하는 데 충분한 정보만 제공하면 됨 
  - 페이지 하나에 key를 더 많이 채우면, 더 높은 분기 계수를 얻어 depth를 줄일 수 있음
- 페이지는 디스크 상 어디에나 위치 가능 
  - 키 범위가 가까운 페이지들이 디스크 상에 가까이 있어야 할 필요가 없기 때문 
  - 하지만 질의가 정렬된 순서로 키 범위의 상당 부분을 스캔해야 한다면, 모든 페이지에 대해 디스크 탐색이 필요 → 페이지 단위 배치는 비효율적이 됨  
  - 따라서, B Tree 구현에서 leaf 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리를 배치하려고 시도함 
    - 트리가 커지면 순서 유지가 어려움 
    - LSM 트리는 병합 과정에서 큰 segment를 한번에 다시 씀 → 디스크에서 연속된 키를 서로 가깝게 유지하기 더 쉬움 
- 트리에 포인터 추가 
  - 각 leaf 페이지가 양쪽 형제 페이지에 대한 참조를 가지고 있게 함 
  - 상위 페이지로 다시 이동하지 않아도 순서대로 키 스캔 가능 
- Fractal tree
  - B Tree의 변형
  - 디스크 탐색을 줄이기 위해 LSM 트리의 개념을 일부 빌림 


## B Tree vs LSM Tree